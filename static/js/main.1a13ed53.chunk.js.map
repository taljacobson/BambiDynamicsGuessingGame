{"version":3,"sources":["app/hooks.ts","features/pageStore.ts","pages/gameForm/index.tsx","pages/gamePage/index.tsx","pages/intro/index.tsx","App.tsx","features/counter/counterAPI.ts","features/counter/counterSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","DB_SCORES","initialState","page","words","lives","points","scores","fetchWordsAsync","createAsyncThunk","a","Promise","resolve","setTimeout","data","response","fetchScoresAsync","JSON","parse","localStorage","getItem","console","log","counterSlice","createSlice","name","reducers","changePage","state","action","payload","startGame","wordMiss","wordHit","submitForm","push","setItem","stringify","extraReducers","builder","addCase","fulfilled","map","word","difficulty","length","value","split","latter","index","Math","random","join","originalValue","sort","b","actions","selectPage","selectWords","selectScores","selectLives","selectPoints","GameFormPage","score","dispatch","className","onSubmit","e","preventDefault","target","phone","required","type","minLength","GamePage","useState","setValue","wordIndex","setWordIndex","useEffect","style","color","prev","autoFocus","onChange","maxLength","ScoresItem","IntroPage","hasWords","_scores","useMemo","disabled","onClick","key","App","currentPage","fallback","fetchCount","amount","incrementAsync","status","increment","decrement","incrementByAmount","pending","store","configureStore","reducer","counter","counterReducer","pageReducer","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.1a13ed53.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState } from '../app/store';\n\nconst DB_SCORES = 'scores';\n\n\ntype PAGES = 'intro' | 'game' | 'form'\n\nexport interface Word {\n    value: string;\n    originalValue: string;\n    difficulty: number;\n}\n\nexport interface Scores {\n    name: string;\n    score: number;\n    phone?: string;\n}\n\nfunction getWords() {\n    // TODO find some external API that returns random words\n    return new Promise<{ data: string[] }>((resolve) =>\n        setTimeout(() => resolve({ data: ['hello', 'react', 'redux', 'supercalifragilisticexpialidocious'] }), 500)\n    );\n}\n\nfunction getScores() {\n    return new Promise<{ data: Scores[] }>((resolve) =>\n    setTimeout(() =>  resolve({data : JSON.parse(localStorage.getItem(DB_SCORES) ?? '[]') ?? [] }), 0)\n    );\n}\n\nexport interface pageState {\n    page: PAGES;\n    words: Word[];\n    lives: number,\n    points: number;\n    scores: Scores[]\n}\n\n\n\nconst initialState: pageState = {\n    page: 'intro',\n    words: [],\n    lives: 3,\n    points: 0,\n    scores: []\n};\n\nexport const fetchWordsAsync = createAsyncThunk(\n    'page/fetchWords',\n    async () => {\n        const response = await getWords();\n        return response.data;\n    }\n);\n\nexport const fetchScoresAsync = createAsyncThunk(\n    'page/scores',\n    async () => {\n        const response = await getScores();\n        console.log(response)\n        return response.data;\n    }\n);\n\nexport const counterSlice = createSlice({\n    name: 'page',\n    initialState,\n    reducers: {\n        changePage: (state, action: PayloadAction<PAGES>) => {\n            state.page = action.payload;\n        },\n        startGame: (state) => {\n            state.page = 'game';\n            state.lives = initialState.lives;\n        },\n        wordMiss: (state) => {\n            const lives = state.lives - 1;\n            if (lives <= 0) {\n                state.page = 'form'\n            } else {\n                state.lives = lives;\n            }\n        },\n        wordHit: (state) => {\n\n            const points = state.points + 1;\n\n            state.points = points;\n\n        },\n\n        submitForm: (state, action: PayloadAction<Scores>) => {\n            state.scores.push(action.payload)\n            state.page = 'intro';\n\n            localStorage.setItem(DB_SCORES, JSON.stringify(state.scores))\n        }\n\n    },\n    extraReducers: (builder) => {\n        builder\n            .addCase(fetchWordsAsync.fulfilled, (state, action) => {\n                const words = action.payload.map((word) => {\n\n                    // TODO find a better way to judge difficulty\n                    const difficulty = word.length;\n\n                    const value = word.split('').map((latter, index) => {\n                        if (index === 0 || index === word.length - 1) {\n                            return latter;\n                        }\n                        return Math.random() > .5 && index % 3 ? '_' : latter\n                    }).join('');\n\n                    return {\n                        originalValue: word,\n                        difficulty,\n                        value,\n                    } as Word\n\n                }).sort((a, b) => a.difficulty > b.difficulty ? 1 : -1);\n\n\n                state.words = words;\n            });\n\n        builder\n            .addCase(fetchScoresAsync.fulfilled, (state, action) => {\n                state.scores = action.payload ?? []\n            })\n    },\n});\n\nexport const { changePage, startGame, wordHit, wordMiss, submitForm } = counterSlice.actions;\n\nexport const selectPage = (state: RootState) => state.page.page;\nexport const selectWords = (state: RootState) => state.page.words;\nexport const selectScores = (state: RootState) => state.page.scores;\n\nexport const selectLives = (state: RootState) => state.page.lives;\nexport const selectPoints = (state: RootState) => state.page.points;\n\n\n\nexport default counterSlice.reducer;\n","import { useAppDispatch, useAppSelector } from \"../../app/hooks\";\nimport { selectPoints, submitForm } from \"../../features/pageStore\";\n\nfunction GameFormPage() {\n    const score = useAppSelector(selectPoints);\n    const dispatch = useAppDispatch();\n    const onSubmit: React.FormEventHandler<HTMLFormElement> = (e) => {\n        e.preventDefault();\n        const name = (e.target as any).name.value;\n        const phone = (e.target as any).phone.value\n        console.log(name, phone)\n        dispatch(submitForm({\n            score,\n            name,\n            phone,\n        }))\n    }\n\n    return <div>\n        <h4>game over... better luck next time</h4>\n        <h3 className=\"gameForm-score\"><span>your score</span> <strong>{score}</strong> </h3>\n\n        <form className=\"gameFormForm\" onSubmit={onSubmit}>\n            <label>\n                <span>name: </span>\n                <input required name=\"name\" type=\"text\" minLength={2} />\n            </label>\n            <br />\n            <label>\n                <span>phone: </span>\n                <input name=\"phone\" type=\"phone\" />\n            </label>\n            <br />\n            <button className=\"checkbtn playbtn\">sumbit</button>\n        </form>\n    </div>\n}\n\nexport default GameFormPage;","import { useEffect, useState } from \"react\";\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\"\nimport { changePage, selectLives, selectWords, wordHit, wordMiss } from \"../../features/pageStore\"\n\n\nfunction GamePage() {\n    const words = useAppSelector(selectWords);\n    const lives = useAppSelector(selectLives);\n    const dispatch = useAppDispatch();\n\n    const [value, setValue] = useState('')\n\n    const [wordIndex, setWordIndex] = useState(0)\n    const word = words[wordIndex];\n\n    const onCheckGuess: React.FormEventHandler<HTMLFormElement> = (e) => {\n        e.preventDefault();\n        if (value === word.originalValue) {\n            // todo success - change to next word, maybe set a timeout with some green success animation.\n            setWordIndex((prev) => prev + 1);\n            setValue('');\n            dispatch(wordHit())\n        } else {\n            setValue('');\n            dispatch(wordMiss())\n        }\n    }\n\n    useEffect(() => {\n\n        if (wordIndex === words.length) {\n            // if last word go to form page\n            dispatch(changePage('form'))\n        }\n\n    }, [dispatch, wordIndex, words.length])\n\n    if (!word) {\n        return <div />\n    }\n\n    return <div className=\"game-page\">\n        <h6>game Page</h6>\n        <h5 className=\"lives-left\">lives left\n            <span style={\n                { color: lives <= 1 ? 'red' : 'inherit' }\n            } >{lives}</span> </h5>\n        <h1 className=\"game-value\" >\n            {word.value}\n        </h1>\n        <form onSubmit={onCheckGuess} >\n            <input autoFocus className=\"game-input\" type=\"text\" onChange={(e) => setValue(e.target.value)} maxLength={word.originalValue.length} value={value} />\n            <br />\n            <button className=\"checkbtn playbtn\" >check Guess</button>\n        </form>\n    </div>\n}\n\nexport default GamePage","import React, { useEffect, useMemo } from 'react';\nimport { useAppDispatch, useAppSelector } from '../../app/hooks';\nimport { fetchScoresAsync, fetchWordsAsync, Scores, selectScores, selectWords, startGame } from '../../features/pageStore';\n\nconst ScoresItem: React.FC<Scores> = ({ name, score, phone }) => {\n    return <div className=\"score-item\">\n\n        <div className=\"score-item-inner\">\n            <span className=\"score-item-title\" >{name}\n            </span>\n            {phone &&\n                <caption className=\"score-item-subtitle\">\n                    {phone}\n                </caption>\n            }\n        </div>\n        <div className=\"score-item-score\">{score}</div>\n    </div>\n}\n\nfunction IntroPage() {\n    const dispatch = useAppDispatch();\n    const hasWords = useAppSelector(selectWords)\n    const scores = useAppSelector(selectScores);\n    const _scores = useMemo(() => {\n\n        return [...scores].sort((a, b) => b.score - a.score);\n    }, [scores])\n    useEffect(() => {\n        dispatch(fetchWordsAsync());\n        dispatch(fetchScoresAsync());\n    }, [dispatch])\n\n\n    return <div className=\"intro-page\">\n\n        <h1>welcome to<br /> the geussing game</h1>\n        <button\n            className=\"playbtn\"\n            disabled={hasWords.length === 0}\n            onClick={() => dispatch(startGame())}\n        >start</button>\n\n        {scores && scores.length > 1 && (<div>\n\n            <h5>Scores</h5>\n            <div>\n                {\n                    _scores.map((score) => <ScoresItem {...score} key={`${score.name}${score.score}`} />)\n                }\n            </div>\n\n        </div>)\n\n        }\n    </div>\n}\n\n\nexport default IntroPage;","\nimport React, { Suspense } from 'react';\nimport './App.css';\nimport { useAppSelector } from './app/hooks';\nimport { selectPage } from './features/pageStore';\nimport GameFormPage from './pages/gameForm';\nimport GamePage from './pages/gamePage';\nimport IntroPage from './pages/intro';\n\nfunction App() {\n  const currentPage = useAppSelector(selectPage)\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-container\">\n        <Suspense fallback={() => <div>Loading</div>}>\n          {currentPage === 'intro' && <IntroPage />}\n          {currentPage === 'game' && <GamePage />}\n          {currentPage === 'form' && <GameFormPage />}\n        </Suspense>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// A mock function to mimic making an async request for data\nexport function fetchCount(amount = 1) {\n  return new Promise<{ data: number }>((resolve) =>\n    setTimeout(() => resolve({ data: amount }), 500)\n  );\n}\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState, AppThunk } from '../../app/store';\nimport { fetchCount } from './counterAPI';\n\nexport interface CounterState {\n  value: number;\n  status: 'idle' | 'loading' | 'failed';\n}\n\nconst initialState: CounterState = {\n  value: 0,\n  status: 'idle',\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const incrementAsync = createAsyncThunk(\n  'counter/fetchCount',\n  async (amount: number) => {\n    const response = await fetchCount(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    increment: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementAsync.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(incrementAsync.fulfilled, (state, action) => {\n        state.status = 'idle';\n        state.value += action.payload;\n      });\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectCount = (state: RootState) => state.counter.value;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\nexport const incrementIfOdd = (amount: number): AppThunk => (\n  dispatch,\n  getState\n) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 1) {\n    dispatch(incrementByAmount(amount));\n  }\n};\n\nexport default counterSlice.reducer;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport counterReducer from '../features/counter/counterSlice';\nimport pageReducer from '../features/pageStore';\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterReducer,\n    page: pageReducer,\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}